Index: bot.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import asyncio\r\nimport discord\r\nimport time\r\nimport youtube_dl\r\n\r\nfrom discord.ext import commands\r\nfrom fonctions import *\r\n\r\n# ID : 653563141002756106\r\n# https://discordapp.com/oauth2/authorize?&client_id=653563141002756106&scope=bot&permissions=8\r\n\r\nclient = discord.Client()\r\nbot = commands.Bot(command_prefix=\"--\", description=\"Le p'tit bot !\")\r\n\r\n\r\n# On ready message\r\n@bot.event\r\nasync def on_ready():\r\n    print('Logged in as')\r\n    print(bot.user.name)\r\n    print(bot.user.id)\r\n    print('------')\r\n\r\n\r\n# Get every message sent, stocked in 'message'\r\n@bot.event\r\nasync def on_message(message):\r\n    channel = message.channel\r\n    Message = message.content.lower()\r\n    rdnb = random.randint(1, 5)\r\n\r\n    # open and stock the dico, with a lot of words\r\n    dico_file = open(\"txt/dico.txt\", \"r+\")\r\n    dico_lines = dico_file.readlines()\r\n    dico_size = len(dico_lines)\r\n    dico_file.close()\r\n\r\n    if message.author == bot.user:  # we don't want the bot to repeat itself\r\n        return\r\n\r\n    # expansion of the dico, with words of every messages (stock only words, never complete message)\r\n    if message.author.id != 696099307706777610:  # we don't what a specific bot (from a friend) to expand the dico\r\n        if \"```\" in Message:\r\n            return\r\n        mot = \"\"\r\n        for i in range(len(Message)):\r\n            mot += Message[i]\r\n            if Message[i] == \" \" or i == len(Message) - 1:\r\n                ponctuation = [\" \", \".\", \",\", \";\", \"!\", \"?\", \"(\", \")\", \"[\", \"]\", \":\", \"*\"]\r\n                for j in ponctuation:\r\n                    mot = mot.replace(j, \"\")\r\n                if verifAlphabet(mot) and 0 < len(mot) < 27:\r\n                    mot += \"\\n\"\r\n                    if mot not in dico_lines:\r\n                        print(mot)\r\n                        dico_lines.append(mot)\r\n                mot = \"\"\r\n\r\n    dico_lines.sort()\r\n    if len(dico_lines) > 0 and len(dico_lines) > dico_size:\r\n        dico_file = open(\"txt/dico.txt\", \"w+\")\r\n        for i in dico_lines:\r\n            dico_file.write(i)\r\n        dico_file.close()\r\n\r\n    # stock file full of insults (yes I know...)\r\n    fichier_insulte = open(\"txt/insultes.txt\", \"r\")\r\n    lines_insultes = fichier_insulte.readlines()\r\n    insultes = []\r\n    for i in lines_insultes:\r\n        i = i.replace(\"\\n\", \"\")\r\n        insultes.append(i)\r\n    fichier_insulte.close()\r\n\r\n    if message.content.startswith('--addYoutube'):\r\n        print(\"Ajout de video...\")\r\n        mot = str(Message)\r\n        mot = mot.replace(\"--addyoutube \", \"\")\r\n        mot = '\\n' + mot\r\n        fichier_youtube = open(\"txt/youtube.txt\", \"a\")\r\n        fichier_youtube.write(mot)\r\n        fichier_youtube.close()\r\n        print(ytb)\r\n        text = ytb[len(ytb) - 1]\r\n        await channel.send(text)\r\n\r\n    if message.content.startswith('--searchYoutube'):\r\n        print(\"Recherche de video...\")\r\n        Message = message.content\r\n        mot = str(Message)\r\n        mot = mot.replace(\"--searchyoutube \", \"\")\r\n        mots = [mot[0]]\r\n        k = 0\r\n        for i in range(1, len(mot)):\r\n            if mot[i] == ' ':\r\n                k += 1\r\n                mots.append(\"\")\r\n            else:\r\n                mots[k] += mot[i]\r\n        fichier_youtube = open('txt/youtube.txt')\r\n        youtubes_lines = fichier_youtube.readlines()\r\n        for i in youtubes_lines:\r\n            for k in mots:\r\n                print(k, \" \", i)\r\n                if k in i:\r\n                    text = i\r\n                    await channel.send(text)\r\n        fichier_youtube.close()\r\n\r\n    if message.content.startswith('--addInsult'):\r\n        print(\"Ajout d'insulte...\")\r\n        mot = str(message.content)\r\n        mot = mot.replace(mot[0:12], \"\")\r\n        if len(mot) <= 2:\r\n            await channel.send(\"Sympa l'insulte...\")\r\n            return\r\n        mot = '\\n' + mot\r\n        fichier_insulte = open(\"txt/insultes.txt\", \"a\")\r\n        fichier_insulte.write(mot)\r\n        fichier_insulte.close()\r\n        text = insultes[len(insultes) - 1]\r\n        await channel.send(text)\r\n\r\n    if Message.startswith(\"--song\"):\r\n        fichier_music = open(\"txt/music.txt\", \"r\")\r\n        lines_music = fichier_music.readlines()\r\n        music = []\r\n        for i in lines_music:\r\n            i = i.replace(\"\\n\", \"\")\r\n            music.append(i)\r\n        fichier_music.close()\r\n\r\n        song = \"Mauvaise commande.. Pffff... Essaye *help*\"\r\n        if 'add' in Message:\r\n            if \"https://\" not in Message and (\"youtu\" not in Message or \"spotify\" not in Message or\r\n                                              \"deezer\" not in Message or \"apple\" not in Message):\r\n                song = \"Arretes d'envoyer des nudes, et envoie plutot une URL valide.. Tsss...\"\r\n            elif \"index\" in Message:\r\n                song = \"Elle est mignonne ta playlist, mais je veux l'URL seule. Merci <3\"\r\n\r\n            else:\r\n                song = message.content\r\n                song = song.replace(\"--song add \", \"\")\r\n                if song in lines_music:\r\n                    song = \"Ta musique y est déjà !\"\r\n                else:\r\n                    song = '\\n' + song\r\n                    fichier_music = open(\"txt/music.txt\", \"a\")\r\n                    fichier_music.write(song)\r\n                    print(\"Music\", Message)\r\n                    song = 'Alright'\r\n\r\n        elif 'all' in Message:\r\n            song = music\r\n            print(music)\r\n\r\n        elif 'random' in Message:\r\n            Message = Message.replace(\"--song \", \"\")\r\n            song = random.choice(music)\r\n            print(\"sending\", song)\r\n\r\n        await channel.send(song)\r\n\r\n    # ping a people 10 time, once every 3 sec\r\n    if Message.startswith(\"--appel <@\") and channel.guild != \"EFREI International 2025\":\r\n        if \"<@!653563141002756106>\" in Message:\r\n            await channel.send(\"T'es un marrant toi\")\r\n        else:\r\n            nom = Message.replace(\"--appel \", \"\")\r\n            liste = [\"Allo \", \"T'es la ? \", \"Tu viens \", \"On t'attend...\", \"Ca commence a faire long \",\r\n                     \"Tu viens un jour ??? \", \"J'en ai marre de toi... \", \"Allez grouille !! \",\r\n                     \"Toujours en rertard de toute facon... \", \"ALLOOOOOOOOOOOOOOOOOOOOOOOOOO \"]\r\n            for i in range(10):\r\n                text = liste[i] + nom\r\n                await channel.send(text)\r\n                time.sleep(3)\r\n\r\n    # if you tag this bot in any message (without the above command)\r\n    if \"<@!653563141002756106>\" in Message and \"appel\" not in Message:\r\n        user = str(message.author)\r\n        user = user.replace(user[len(user) - 5:len(user)], \"\")\r\n        rep = [\"ya quoi ?!\", \"Qu'est ce que tu as \" + user + \" ?\", \"Oui c'est moi\", \"Présent !\", \"*Oui ma bicheuh <3*\"]\r\n        if user == \"Le Grand bot\":\r\n            rep.append('Oui bb ?')\r\n            rep.append('Yo <@!747066145550368789>')\r\n        await channel.send(random.choice(rep))\r\n\r\n    # send 5 randoms words from the dico\r\n    if Message == \"--random\":\r\n        text = \"\"\r\n        rd_dico = dico_lines\r\n        random.shuffle(rd_dico)\r\n        for i in range(5):\r\n            text += rd_dico[i]\r\n            if i != 4:\r\n                text += \" \"\r\n        text += \".\"\r\n        text = text.replace(\"\\n\", \"\")\r\n        text = text.replace(text[0], text[0].upper(), 1)\r\n        await channel.send(text)\r\n\r\n    # send the number of words stocked in the dico\r\n    if Message == '--dico':\r\n        text = \"J'ai actuellement \" + str(len(dico_lines)) + \" mots enregistrés, nickel\"\r\n        await channel.send(text)\r\n\r\n    # begginning of reaction programs, get inspired\r\n\r\n    if Message.startswith(\"hein\"):\r\n        await channel.send(\"deux.\")\r\n\r\n    if Message == 'pas mal':\r\n        reponses = [\"mouais\", \"peut mieux faire\", \"woaw\", \":o\"]\r\n        await channel.send(random.choice(reponses))\r\n\r\n    if Message == \"ez\" or Message == \"easy\":\r\n        reponses = [\"https://tenor.com/view/walking-dead-easy-easy-peasy-lemon-squeazy-gif-7268918\"]\r\n        await channel.send(random.choice(reponses))\r\n\r\n    if Message == 'bite' or Message == 'zizi':\r\n        text = \"8\" + '=' * random.randint(0, 9) + \"D\"\r\n        await channel.send(text)\r\n\r\n    if 'yanis' in Message and rdnb == 5:\r\n        await channel.send(\"La Bretagne c'est pas ouf.\")\r\n\r\n    if Message.startswith(\"stop\") or Message.startswith(\"arrête\") or Message.startswith(\"arrete\"):\r\n        await channel.send(\"https://tenor.com/view/stop-it-get-some-help-gif-7929301\")\r\n\r\n    if Message.startswith(\"exact\"):\r\n        reponses = [\"Je dirais même plus, exact.\", \"Il est vrai\", \"AH BON ??!\", \"C'est cela\", \"Plat-il ?\", \"Jure ?\"]\r\n        await channel.send(random.choice(reponses))\r\n\r\n    if Message == '<3':\r\n        reponses = [\"Nique ta tante (pardon)\", \"<3\", \"luv luv\", \"moi aussi je t'aime ❤\"]\r\n        await channel.send(random.choice(reponses))\r\n\r\n    if Message == 'toi-même' or Message == \"toi-meme\" or Message == \"toi même\" or Message == \"toi meme\":\r\n        reponses = [\"Je ne vous permet pas\", \"Miroir magique\", \"C'est celui qui dit qui l'est\"]\r\n        await channel.send(random.choice(reponses))\r\n\r\n    if \"<@!747066145550368789>\" in message.content:\r\n        reponses = ['bae', 'Ah oui, cette sous-race de <@!747066145550368789>', \"il a moins de bits que moi\",\r\n                    \"son pere est un con\", \"ca se dit grand mais tout le monde sait que....\"]\r\n        await channel.send(random.choice(reponses))\r\n\r\n    if Message == '❤':\r\n        await channel.send('❤')\r\n\r\n    if Message == \"ben\":\r\n        await channel.send(\"je suis sa pute\")\r\n\r\n    if Message == '1':\r\n        await channel.send(\"2\")\r\n\r\n        # waits for a message valiudating further instructions\r\n        def check(m):\r\n            return m.content == \"3\" and m.channel == message.channel\r\n\r\n        await bot.wait_for('message', check=check)\r\n        await channel.send(\"SOLEIL !\")\r\n\r\n    if Message == 'a':\r\n        def check(m):\r\n            return m.content == \"b\" and m.channel == message.channel\r\n\r\n        await bot.wait_for('message', check=check)\r\n        await channel.send(\"A B C GNEU GNEU MARRANT TROU DU CUL !!!\")\r\n\r\n    if Message == 'ah':\r\n        if rdnb >= 4:\r\n            reponses = [\"Oh\", \"Bh\"]\r\n            await channel.send(random.choice(reponses))\r\n        else:\r\n            await channel.send(finndAndReplace('a', dico_lines))\r\n\r\n    if Message == 'oh':\r\n        if rdnb >= 4:\r\n            reponses = ['Quoi ?', 'p', 'ah', ':o']\r\n            await channel.send(random.choice(reponses))\r\n        else:\r\n            await channel.send(finndAndReplace('o', dico_lines))\r\n\r\n    if Message == 'eh':\r\n        if rdnb >= 4:\r\n            reponses = ['hehehehehe', 'oh']\r\n            await channel.send(random.choice(reponses))\r\n        else:\r\n            await channel.send(finndAndReplace('é', dico_lines))\r\n\r\n    if Message.startswith('merci'):\r\n        if rdnb > 3:\r\n            reponses = ['De rien hehe', \"C'est normal t'inquiète\", \"Je veux le cul d'la crémière avec.\", 'non.',\r\n                        'Excuse toi non ?', 'Au plaisir']\r\n            await channel.send(random.choice(reponses))\r\n        else:\r\n            await message.add_reaction(\"\uD83E\uDD70\")\r\n\r\n    if Message == 'skusku' or Message == 'sku sku':\r\n        await channel.send(\"KICÉKIJOUE ????\")\r\n\r\n    if ('\uD83D\uDE22' in Message or '\uD83D\uDE2D' in Message) and rdnb >= 3:\r\n        reponses = ['cheh', 'dur dur', \"dommage mon p'tit pote\", \"balec\"]\r\n        await channel.send(random.choice(reponses))\r\n\r\n    if Message.startswith('tu veux'):\r\n        reponses = ['Ouais gros', 'Carrément ma poule', 'Mais jamais tes fou ptdr', 'Oui.']\r\n        await channel.send(random.choice(reponses))\r\n\r\n    if Message.startswith('quoi'):\r\n        reponses = ['feur', 'hein ?', 'nan laisse', 'oublie', 'rien']\r\n        await channel.send(random.choice(reponses))\r\n\r\n    if Message.startswith('pourquoi'):\r\n        reponses = ['PARCEQUEEEE', 'Aucune idée.', 'Demande au voisin', 'Pourquoi tu demandes ça ?']\r\n        await channel.send(random.choice(reponses))\r\n\r\n    if Message.startswith(\"t'es sur\"):\r\n        reponses = ['Ouais gros', 'Nan pas du tout', 'Qui ne tente rien...']\r\n        await channel.send(random.choice(reponses))\r\n\r\n    if Message.startswith(\"ah ouais\") or Message.startswith(\"ah bon\"):\r\n        reponses = ['Ouais gros', 'Nan ptdr', 'Je sais pas écoute...']\r\n        await channel.send(random.choice(reponses))\r\n\r\n    if Message.startswith(\"lourd\") and rdnb >= 4:\r\n        await channel.send(\"Sku sku\")\r\n\r\n    if '<@!321216514986606592>' in Message:\r\n        await channel.send(\"Encore lui ?\")\r\n\r\n    if '<@!761898936364695573>' in Message:\r\n        await channel.send(\"Tu parles comment de mon pote là ?\")\r\n\r\n    if '<@!392746536888696834>' in Message:\r\n        reponses = ['Ce trouduc.', 'Ce connard.', 'Ce petit con.', 'Cette petite pute.']\r\n        await channel.send(random.choice(reponses))\r\n\r\n    if 'tg' in Message:\r\n        await channel.send(random.choice(insultes))\r\n\r\n    if Message == 'cheh' or Message == 'sheh':\r\n        if rdnb >= 3:\r\n            reponses = [\"Oh tu t'excuses\", \"Cheh\", \"C'est pas gentil ça\", \"\uD83D\uDE41\"]\r\n            await channel.send(random.choice(reponses))\r\n        else:\r\n            await message.add_reaction(\"\uD83E\uDD70\")\r\n\r\n    if \"el ali\" in Message or \"ali oula\" in Message:\r\n        await channel.send(\"\uD83D\uDCA9\")\r\n\r\n    if Message == 'non':\r\n        reponses = ['si.', \"ah bah ca c'est sur\", \"SÉRIEUX ??\", \"logique aussi\", \"jure ?\"]\r\n        await channel.send(random.choice(reponses))\r\n\r\n    if Message.startswith('lequel') and Message[4] != 'q':\r\n        await channel.send('Le deuxième.')\r\n\r\n    if Message.startswith('laquelle'):\r\n        await channel.send('La deuxième.')\r\n\r\n    if Message.startswith('miroir magique'):\r\n        await channel.send(Message)\r\n\r\n    if Message.startswith(\"jure\"):\r\n        if \"wola\" in Message:\r\n            await channel.send(\"Wola\")\r\n        elif \"wallah\" in Message:\r\n            await channel.send(\"Wallah\")\r\n\r\n    if \"☹\" in Message or \"\uD83D\uDE1E\" in Message or \"\uD83D\uDE26\" in Message:\r\n        await message.add_reaction(\"\uD83E\uDD70\")\r\n\r\n    if Message == 'bv':\r\n        await channel.send(\"Tes parents t'ont appris la politesse, alors on dit MERCI\")\r\n\r\n    if Message == 'f' or Message == 'rip':\r\n        await channel.send(\"#####\\n#\\n#\\n####\\n#\\n#\\n#       to pay respect\")\r\n\r\n    if ('quentin' in Message or 'quent1' in Message) and rdnb >= 3:\r\n        await channel.send(\"Papa ! \uD83E\uDD17\")\r\n\r\n    if Message.startswith(\"god\"):\r\n        Message = Message.replace(\"god\", \"\")\r\n        if rdnb >= 3:\r\n            await channel.send(\"Nope, not him.\")\r\n            return\r\n        userID = \"\"\r\n        if \"<@!\" not in Message:\r\n            userID = int(message.author.id)\r\n        else:\r\n            i = 0\r\n            for i in range(len(Message)):\r\n                if Message[i] == '<' and Message[i + 1] == '@' and Message[i + 2] == '!':\r\n                    i += 3\r\n                    userID = \"\"\r\n                    break\r\n            while Message[i] != '>' and i < len(Message):\r\n                userID += Message[i]\r\n                i += 1\r\n            userID = int(userID)\r\n        user = await message.guild.fetch_member(userID)\r\n        pfp = user.avatar_url\r\n        embed = discord.Embed(title=\"This is God\", description='<@%s> is god.' % userID, color=0xecce8b)\r\n        embed.set_thumbnail(url=pfp)\r\n\r\n        await channel.send(\"God looks like him.\", embed=embed)\r\n\r\n    if Message.startswith(\"hello\"):\r\n        await channel.send(file=discord.File('images/helo.jpg'))\r\n\r\n    if Message == \"enculé\" or Message == \"enculer\":\r\n        image = ['images/tellermeme.png', 'images/bigard.jpeg']\r\n        await channel.send(file=discord.File(random.choice(image)))\r\n\r\n    if Message == \"stonks\":\r\n        await channel.send(file=discord.File('images/stonks.png'))\r\n\r\n    if Message == \"parfait\" or Message == \"perfection\":\r\n        await channel.send(file=discord.File('images/perfection.jpg'))\r\n\r\n    if 'pute' in Message:\r\n        reponses = [\"https://tenor.com/view/mom-gif-10756105\",\r\n                    \"https://tenor.com/view/wiener-sausages-hotdogs-gif-5295979\",\r\n                    \"https://i.ytimg.com/vi/3HZ0lvpdw6A/maxresdefault.jpg\"]\r\n        await channel.send(random.choice(reponses))\r\n\r\n    if \"guillotine\" in Message:\r\n        reponses = ['https://tenor.com/view/guillatene-behead-lego-gif-12352396',\r\n                    'https://tenor.com/view/guillotine-gulp-worried-scared-slug-riot-gif-11539046',\r\n                    'https://tenor.com/view/revolution-guillotine-marie-antoinette-off-with-their-heads-behead-gif-12604431']\r\n        await channel.send(random.choice(reponses))\r\n\r\n    if 'pd' in Message:\r\n        Message = ' ' + Message + ' '\r\n        for i in range(len(Message) - 3):\r\n            if Message[i] == ' ' and Message[i + 1] == 'p' and Message[i + 2] == 'd' and Message[i + 3] == ' ':\r\n                await channel.send(file=discord.File('images/pd.jpg'))\r\n\r\n    if 'oof' in Message and rdnb >= 2:\r\n        reponses = ['https://tenor.com/view/oh-snap-surprise-shocked-johncena-gif-5026702',\r\n                    'https://tenor.com/view/oof-damn-wow-ow-size-gif-16490485',\r\n                    'https://tenor.com/view/oof-simpsons-gif-14031953',\r\n                    'https://tenor.com/view/yikes-michael-scott-the-office-my-bad-oof-gif-13450971']\r\n        await channel.send(random.choice(reponses))\r\n\r\n    if ('money' in Message or 'argent' in Message) and rdnb >= 2:\r\n    \treponses = ['https://tenor.com/view/6m-rain-wallstreet-makeitrain-gif-8203989',\r\n    \t\t\t\t'https://tenor.com/view/money-makeitrain-rain-guap-dollar-gif-7391084',\r\n    \t\t\t\t'https://tenor.com/view/taka-money-gif-10114852']\r\n    \tawait channel.send(random.choice(reponses))\r\n\r\n    # teh help command, add commands call, but not reactions\r\n    if Message == '--help':\r\n        await channel.send(\"Commandes : \\n\"\r\n                           \" **F** to pay respect\\n\"\r\n                           \" **--serverInfo** pour connaître les infos du server\\n\"\r\n                           \" **--addInsult** pour ajouter des insultes et **tg** pour te faire insulter\\n\"\r\n                           \" **--addWord** pour ajouter un mot au jeu, et **--game** pour jouer au jeu du **clap**\\n\"\r\n                           \" **--repeat** pour que je répète ce qui vient après l'espace\\n\"\r\n                           \" **--appel** puis le pseudo de ton pote pour l'appeler\\n\"\r\n                           \" **--crypt** pour chiffrer/déchiffrer un message César (décalage)\\n\"\r\n                           \" **--random** pour écrire 5 mots aléatoires\\n\"\r\n                           \" **--randint *nb1*, *nb2* ** pour avoir un nombre aléatoire entre ***nb1*** et ***nb2***\\n\"\r\n                           \" **--calcul *nb1* (+, -, /, *, ^, !) *nb2* ** pour avoir un calcul adéquat \\n\"\r\n                           \" **--isPrime** *nb* pour tester si *nb* est premier\\n\"\r\n                           \" **--prime** *nb* pour avoir la liste de tous les nombres premiers jusqu'a *nb* au minimum\\n\"\r\n                           \" **--poll *question*, *prop1*, *prop2*,..., *prop10* ** pour avoir un sondage de max 10 propositions\\n\"\r\n                           \" **--song** puis : **add** *ajoute un morceau à la liste ([URL youtube] - [titre] - [artiste])*\\n\"\r\n                           \"                         **random** *choisit un morceau dans la liste*\\n\"\r\n                           \"                         **all** *affiche toute la liste*\\n\"\r\n                           \"Et je risque de réagir à tes messages, parfois de manière... **Inattendue** \uD83D\uDE08\")\r\n    else:\r\n        # allows command to process after the on_message() function call\r\n        await bot.process_commands(message)\r\n\r\n\r\n# beginning of the commands\r\n\r\n@bot.command()  # delete 'nombre' messages\r\nasync def clear(ctx, nombre: int):\r\n    messages = await ctx.channel.history(limit=nombre + 1).flatten()\r\n    for message in messages:\r\n        await message.delete()\r\n\r\n\r\n@bot.command()  # repeat the 'text', and delete the original message\r\nasync def repeat(ctx, *text):\r\n    messages = await ctx.channel.history(limit=1).flatten()\r\n    for message in messages:\r\n        await message.delete()\r\n    await ctx.send(\" \".join(text))\r\n\r\n\r\n@bot.command()  # show the number of people in the server, and its name\r\nasync def serverinfo(ctx):\r\n    server = ctx.guild\r\n    nbUsers = server.member_count\r\n    text = f\"Le serveur **{server.name}** contient **{nbUsers}** personnes !\"\r\n    await ctx.send(text)\r\n\r\n\r\n@bot.command()  # same, with a capital letter\r\nasync def serverInfo(ctx):\r\n    await serverinfo(ctx)\r\n\r\n\r\n@bot.command()  # send the 26 possibilites of a ceasar un/decryption\r\nasync def crypt(ctx, *text):\r\n    mot = \" \".join(text)\r\n    messages = await ctx.channel.history(limit=1).flatten()\r\n    for message in messages:\r\n        await message.delete()\r\n    await ctx.send(\"||\" + mot + \"|| :\\n\" + crypting(mot))\r\n\r\n\r\n@bot.command()  # send a random integer between two numbers, or 1 and 0\r\nasync def randint(ctx, *text):\r\n    tab = []\r\n    Message = \"\".join(text)\r\n    nb2 = 0\r\n    i = 0\r\n    while i < len(Message) and Message[i] != ',':\r\n        if 48 <= ord(Message[i]) <= 57:\r\n            tab.append(Message[i])\r\n        i += 1\r\n\r\n    if len(tab) == 0:\r\n        await ctx.send(\"Rentre un nombre banane\")\r\n        return\r\n\r\n    nb1 = strToInt(tab)\r\n\r\n    if i != len(Message):\r\n        nb2 = strToInt(list=nbInStr(Message, i, len(Message)))\r\n\r\n    if nb1 == nb2:\r\n        text = \"Bah \" + str(nb1) + \" du coup... \uD83D\uDE44\"\r\n        await ctx.send(text)\r\n        return\r\n    if nb2 < nb1:\r\n        temp = nb2\r\n        nb2 = nb1\r\n        nb1 = temp\r\n\r\n    rd = random.randint(nb1, nb2)\r\n    print(\"random \", nb1, \":\", nb2, \" = \", rd, sep=\"\")\r\n    await ctx.send(rd)\r\n\r\n\r\n@bot.command()  # same, with a capital letter\r\nasync def randInt(ctx, *text):\r\n    await randint(ctx, *text)\r\n\r\n\r\n@bot.command()  # send a random word from the dico, the first to write it wins\r\nasync def game(ctx):\r\n    dico_file = open(\"txt/dico.txt\", \"r+\")\r\n    dico_lines = dico_file.readlines()\r\n    dico_file.close()\r\n\r\n    mot = random.choice(dico_lines)\r\n    mot = mot.replace('\\n', '')\r\n    text = 'Le premier à écrire **' + mot + '** a gagné'\r\n    await ctx.send(text)\r\n\r\n    if ctx.author == bot.user:\r\n        return\r\n\r\n    def check(m):\r\n        return m.content == mot and m.channel == ctx.channel\r\n\r\n    msg = await bot.wait_for('message', check=check)\r\n    user = str(msg.author)\r\n    user = user.replace(user[len(user) - 5:len(user)], \"\")\r\n    text = '**' + user + '** a gagné !'\r\n    await ctx.send(text)\r\n\r\n\r\n@bot.command()  # do a simple calcul of 2 numbers and 1 operator (or a fractionnal)\r\nasync def calcul(ctx, *text):\r\n    tab = []\r\n    symbols = ['-', '+', '/', '*', '^', '!']\r\n    Message = \"\".join(text)\r\n    Message = Message.lower()\r\n    nb2 = i = rd = 0\r\n\r\n    if 'infinity' in Message:\r\n        text = \"\"\r\n        for i in range(1999):\r\n            text += \"9\"\r\n        await ctx.send(text)\r\n        return\r\n\r\n    while i < len(Message) and 48 <= ord(Message[i]) <= 57:\r\n        if 48 <= ord(Message[i]) <= 57:\r\n            tab.append(Message[i])\r\n        i += 1\r\n\r\n    if len(tab) == 0:\r\n        await ctx.send(\"Rentre un nombre banane\")\r\n        return\r\n\r\n    if i == len(Message) or Message[i] not in symbols:\r\n        await ctx.send(\"Rentre un symbole (+, -, *, /, ^, !)\")\r\n        return\r\n\r\n    symb = Message[i]\r\n\r\n    nb1 = strToInt(tab)\r\n\r\n    if symb == '!':\r\n        if nb1 > 806:  # can't go above 806 recursion deepth\r\n            await ctx.send(\"806! maximum, désolé \uD83E\uDD37\u200D♂️\")\r\n            return\r\n        rd = facto(nb1)\r\n        text = str(nb1) + '!=' + str(rd)\r\n        await ctx.send(text)\r\n        return\r\n\r\n    if i != len(Message):\r\n        tab = nbInStr(Message, i, len(Message))\r\n\r\n        if len(tab) == 0:\r\n            await ctx.send(\"Rentre un deuxième nombre patate\")\r\n            return\r\n\r\n        nb2 = strToInt(tab)\r\n\r\n    if symb == '+':\r\n        rd = nb1 + nb2\r\n    elif symb == '-':\r\n        rd = nb1 - nb2\r\n    elif symb == '*':\r\n        rd = nb1 * nb2\r\n    elif symb == '/':\r\n        if nb2 == 0:\r\n            await ctx.send(\"±∞\")\r\n            return\r\n        rd = float(nb1 / nb2)\r\n    elif symb == '^':\r\n        rd = nb1 ** nb2\r\n    text = str(nb1) + str(symb) + str(nb2) + '=' + str(rd)\r\n    print(text, rd)\r\n    await ctx.send(text)\r\n\r\n\r\n@bot.command()  # create a reaction poll with a question, and max 10 propositions\r\nasync def poll(ctx, *text):\r\n    tab = []\r\n    Message = \" \".join(text)\r\n    text = \"\"\r\n    for i in range(len(Message)):\r\n        if Message[i] == ',':\r\n            tab.append(text)\r\n            text = \"\"\r\n        elif i == len(Message) - 1:\r\n            text += Message[i]\r\n            tab.append(text)\r\n        else:\r\n            text += Message[i]\r\n    if len(tab) <= 1:\r\n        await ctx.send(\"Ecris plusieurs choix séparés par des virgules, c'est pas si compliqué que ça...\")\r\n        return\r\n    if len(tab) > 11:\r\n        await ctx.send(\"Ca commence à faire beaucoup non ?... 10 max ca suffit\")\r\n        return\r\n    text = \"\"\r\n    for i in range(len(tab)):\r\n        if i == 0:\r\n            text += \"❓\"\r\n        elif i == 1:\r\n            text += \"\\n1️⃣\"\r\n        elif i == 2:\r\n            text += \"\\n2️⃣\"\r\n        elif i == 3:\r\n            text += \"\\n3️⃣\"\r\n        elif i == 4:\r\n            text += \"\\n4️⃣\"\r\n        elif i == 5:\r\n            text += \"\\n5️⃣\"\r\n        elif i == 6:\r\n            text += \"\\n6️⃣\"\r\n        elif i == 7:\r\n            text += \"\\n7️⃣\"\r\n        elif i == 8:\r\n            text += \"\\n8️⃣\"\r\n        elif i == 9:\r\n            text += \"\\n9️⃣\"\r\n        elif i == 10:\r\n            text += \"\\n\uD83D\uDD1F\"\r\n        text += tab[i]\r\n\r\n    reponse = await ctx.send(text)\r\n    for i in range(len(tab)):\r\n        if i == 1:\r\n            await reponse.add_reaction(\"1️⃣\")\r\n        elif i == 2:\r\n            await reponse.add_reaction(\"2️⃣\")\r\n        elif i == 3:\r\n            await reponse.add_reaction(\"3️⃣\")\r\n        elif i == 4:\r\n            await reponse.add_reaction(\"4️⃣\")\r\n        elif i == 5:\r\n            await reponse.add_reaction(\"5️⃣\")\r\n        elif i == 6:\r\n            await reponse.add_reaction(\"6️⃣\")\r\n        elif i == 7:\r\n            await reponse.add_reaction(\"7️⃣\")\r\n        elif i == 8:\r\n            await reponse.add_reaction(\"8️⃣\")\r\n        elif i == 9:\r\n            await reponse.add_reaction(\"9️⃣\")\r\n        elif i == 10:\r\n            await reponse.add_reaction(\"\uD83D\uDD1F \")\r\n\r\n\r\n@bot.command()  # find and send all the prime numbers until 14064991, can calcul above but can't send it (8Mb limit)\r\nasync def prime(ctx, nb: int):\r\n    if nb < 2:\r\n        await ctx.send(\"Tu sais ce que ca veut dire 'prime number' ?\")\r\n        return\r\n    Fprime = open(\"txt/primes.txt\", \"r+\")\r\n    primes = Fprime.readlines()\r\n    Fprime.close()\r\n    n_max = int(primes[len(primes) - 1].replace('\\n', \"\"))\r\n    print(n_max)\r\n    text = \"\"\r\n    await ctx.message.add_reaction(\"\uD83D\uDC4D\")\r\n    if n_max < nb:\r\n        if n_max % 2 == 0:\r\n            n_max -= 1\r\n        for i in range(n_max, nb + 1, 2):\r\n            if is_prime(i):\r\n                text += str(i) + '\\n'\r\n        Fprime = open(\"txt/primes.txt\", \"a+\")\r\n        Fprime.write(text)\r\n        Fprime.close()\r\n    if nb > 14064991:  # 8Mb file limit\r\n        text = \"Je peux pas en envoyer plus que 14064991, mais tkt je l'ai calculé chez moi là\"\r\n        await ctx.send(text)\r\n    text = \"Tous les nombres premiers jusqu'a 14064991\"\r\n    await ctx.send(text, file=discord.File(\"txt/prime.txt\"))\r\n\r\n\r\n@bot.command()  # find if 'nb' is a prime number, reacts to the message\r\nasync def isPrime(ctx, nb: int):\r\n    if is_prime(nb):\r\n        await ctx.message.add_reaction(\"\uD83D\uDC4D\")\r\n    else:\r\n        await ctx.message.add_reaction(\"\uD83D\uDC4E\")\r\n\r\n\r\n@bot.command()  # send 'nb' random words of the dico, can repeat itself\r\nasync def randomWord(ctx, nb: int):\r\n    dico_file = open(\"txt/dico.txt\", \"r+\")\r\n    dico_lines = dico_file.readlines()\r\n    dico_file.close()\r\n\r\n    text = \"\"\r\n    for i in range(nb):\r\n        text += random.choice(dico_lines)\r\n        if i != nb - 1:\r\n            text += \" \"\r\n    text += \".\"\r\n    text = text.replace(\"\\n\", \"\")\r\n    text = text.replace(text[0], text[0].upper(), 1)\r\n    await ctx.send(text)\r\n\r\n\r\n@bot.command()  # join the vocal channel fo the caller\r\nasync def join(ctx):\r\n    channel = ctx.author.voice.channel\r\n    await channel.connect()\r\n\r\n\r\n@bot.command()  # leaves it\r\nasync def leave(ctx):\r\n    await ctx.voice_client.disconnect()\r\n\r\n\r\nmusics = {}\r\nytdl = youtube_dl.YoutubeDL()\r\n\r\n\r\n# class of youtube videos (from youtube_dl)\r\nclass Video:\r\n    def __init__(self, link):\r\n        video = ytdl.extract_info(link, download=False)\r\n        video_format = video[\"formats\"][0]\r\n        self.url = video[\"webpage_url\"]\r\n        self.stream_url = video_format[\"url\"]\r\n\r\n\r\n# plays a song in the vocal channel\r\ndef playSong(clt, queue, song):\r\n    source = discord.PCMVolumeTransformer(\r\n        discord.FFmpegPCMAudio(song.stream_url,\r\n                               before_options=\"-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5\"))\r\n\r\n    def next(_):\r\n        if len(queue) > 0:\r\n            newSong = queue[0]\r\n            del queue[0]\r\n            playSong(clt, queue, newSong)\r\n        else:\r\n            asyncio.run_coroutine_threadsafe(clt.disconnect(), bot.loop)\r\n\r\n    clt.play(source, after=next)\r\n\r\n\r\n@bot.command()  # play theyoutube song attached to the URL (TO FIX)\r\nasync def play(ctx, url):\r\n    clt = ctx.guild.voice_client\r\n\r\n    if clt and clt.channel:\r\n        video = Video(url)\r\n        musics[ctx.guild].append(video)\r\n    else:\r\n        video = Video(url)\r\n        musics[ctx.guild] = []\r\n        playSong(clt, musics[ctx.guild], video)\r\n\r\n\r\n\"\"\"\r\n@bot.command()\r\nasync def say(ctx, number, *text):\r\n    for i in range(int(number)):\r\n        await ctx.send(\" \".join(text))\r\n\"\"\"\r\n\r\n# runs the bot (if you have a TOKEN hahaha)\r\nbot.run(TOKEN)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- bot.py	(revision b5a91a75c915075bab5d83f36205ff5e301392d3)
+++ bot.py	(date 1604262061855)
@@ -11,6 +11,7 @@
 
 client = discord.Client()
 bot = commands.Bot(command_prefix="--", description="Le p'tit bot !")
+TOKEN = 'NjUzNTYzMTQxMDAyNzU2MTA2.Xe40Gw.b6wL9sqyrjFxC-fOU900GmJ1vHU'
 
 
 # On ready message
@@ -35,6 +36,89 @@
     dico_size = len(dico_lines)
     dico_file.close()
 
+    # PERSONAL USE ONLY
+    admin_file = open("txt/admin.txt", "r+")
+    admin = admin_file.readlines()
+    admin_file.close()
+
+    if message.author.id == 359743894042443776:
+        if Message.startswith("--shield"):
+            if 'on' in Message:
+                admin[0] = 'True' + str(message.guild.id) + '\n'
+                print("shield ON")
+                await message.add_reaction("👍")
+            else:
+                admin[0] = 'False\n'
+                print("shield OFF")
+                await message.add_reaction("👎")
+
+        if Message.startswith("--printing"):
+            if 'on' in Message:
+                admin[1] = 'True\n'
+                print("print ON")
+                await message.add_reaction("👍")
+            else:
+                admin[1] = 'False\n'
+                print("print OFF")
+                await message.add_reaction("👎")
+
+    admin_file = open("txt/admin.txt", "w+")
+    for i in admin:
+        admin_file.write(str(i))
+    admin_file.close()
+
+    if 'True' in admin[0] and str(message.guild.id) in admin[0]:
+        await message.delete()  # la commande tueuse
+
+    if 'True' in admin[1]:
+        print(message.content)
+
+    # stock file full of youtube links
+    fichier_ytb = open("txt/youtube.txt", "r")
+    lines_ytb = fichier_ytb.readlines()
+    ytb = []
+    for i in lines_ytb:
+        i = i.replace("\n", "")
+        ytb.append(i)
+    fichier_ytb.close()
+
+    fichier_shp = open("txt/ShPeu.txt", "r")
+    lines_shp = fichier_shp.readlines()
+    shp = []
+    for i in lines_shp:
+        i = i.replace("\n", "")
+        shp.append(i)
+    fichier_shp.close()
+
+    if Message.startswith('youtube shp') or Message.startswith('Youtube shp'):
+        print(ytb)
+        text = random.choice(ytb)
+        await channel.send(text)
+
+    if Message.startswith('all youtube shp') or Message.startswith('All youtube shp'):
+        print(ytb)
+        text = ytb
+        await channel.send(text)
+
+    if Message.startswith('shp') or Message.startswith('ShP') or Message.startswith('ShPeu'):
+        print(shp)
+        text = random.choice(shp)
+        await channel.send(text)
+
+    if Message.startswith('ajouter shp'):
+        print("Ajout de shp...")
+        mot = str(Message)
+        mot = mot.replace("ajouter shp ", "")
+        mot = '\n' + mot
+        fichier_shp = open("txt/ShPeu.txt", "a")
+        fichier_shp.write(mot)
+        fichier_shp.close()
+        print(shp)
+        text = shp[len(shp) - 1]
+        await channel.send(text)
+    # END OF PERSONAL USE
+
+
     if message.author == bot.user:  # we don't want the bot to repeat itself
         return
 
@@ -445,7 +529,7 @@
         await channel.send(random.choice(reponses))
 
     if ('money' in Message or 'argent' in Message) and rdnb >= 2:
-    	reponses = ['https://tenor.com/view/6m-rain-wallstreet-makeitrain-gif-8203989',
+    reponses = ['https://tenor.com/view/6m-rain-wallstreet-makeitrain-gif-8203989',
     				'https://tenor.com/view/money-makeitrain-rain-guap-dollar-gif-7391084',
     				'https://tenor.com/view/taka-money-gif-10114852']
     	await channel.send(random.choice(reponses))
@@ -821,6 +905,93 @@
         musics[ctx.guild] = []
         playSong(clt, musics[ctx.guild], video)
 
+@bot.command()
+async def arbres(ctx, *ex):
+    exo = "".join(ex)
+    f_arbes = open("D:/Quentin/Documents/Cours/L2/Info/C/arbres/main.c", "r+")
+    arbres_lines = f_arbes.readlines()
+    f_arbes.close()
+    text = ""
+    for i in range(len(arbres_lines)):
+        if exo in arbres_lines[i]:
+            while "end" not in arbres_lines[i]:
+                text += arbres_lines[i]
+                i += 1
+            break
+    if len(text) > 0:
+        text = "```" + text + "```"
+        await ctx.send(text)
+    else:
+        await ctx.send("Nope, j'ai pas trouvé, désolé mon bro !")
+
+
+@bot.command()  # PERSONAL COMMAND ONLY
+async def AmongUs(ctx):
+    ids = [321216514986606592, 135784465065574401, 349548485797871617, 359743894042443776]
+    print(ctx.message.author.id)
+    if ctx.author.id not in ids:
+        await ctx.send("Tu n'as pas les permissions 😶")
+        return
+    f_name = open("txt/names.txt", "r+")
+    all_names = f_name.readlines()
+    random.shuffle(all_names)
+    f_name.close()
+    random.shuffle(all_names)
+
+    text = "**C'est partie ! On joue avec " + str(len(all_names)) + " joueurs !**"
+    await ctx.send(text)
+    tour = 0
+    modos = ['NozZy', 'Trivarius', 'Skiep', 'Cybonix', 'BlackSterben']
+    while 1:
+        tour += 1
+        f_name = open("txt/names.txt", "r+")
+        all_names = f_name.readlines()
+        random.shuffle(all_names)
+        f_name.close()
+        random.shuffle(all_names)
+
+        random.shuffle(modos)
+        """
+        for j in range(-9, -5):
+            size = -j
+            if len(all_names)%size == 0:
+                print(size)
+                break
+
+        for i in range(0, len(all_names)//size):
+            names.append([''] * size)            
+
+            for j in range(size):
+                all_names[i*size+j] = all_names[i*size+j].replace("\n", "")
+                names[i][j] = all_names[i*size+j]
+        """
+        names = equal_games(all_names)
+        # print("Equipes : ", names)
+
+        color = [0x0000ff, 0x740001, 0x458b74, 0x18eeff, 0xeae4d3, 0xff8100, 0x9098ff, 0xff90fa, 0xff1443, 0xff1414,
+                 0x7fffd4, 0x05ff3c, 0x05ffa1]
+        text = "**Partie n°" + str(tour) + "**"
+        await ctx.send(text)
+        for i in range(len(names)):
+            if i < len(modos):
+                mod = modos[i]
+            else:
+                mod = "sans modo"
+            embed = discord.Embed(title=("**Equipe " + mod + "**"), color=random.choice(color))
+            embed.set_thumbnail(url="https://i.redd.it/1y3vw360an031.png")
+            for y in range(0, len(names[i])):
+                embed.add_field(name=("Joueur " + str(y + 1)), value=names[i][y], inline=True)
+            await ctx.send(embed=embed)
+
+        def check(m):
+            id_list = [321216514986606592, 359743894042443776, 135784465065574401, 349548485797871617]
+            return (m.content == "NEXT" or m.content == "END") and m.channel == ctx.channel and m.author.id in id_list
+
+        msg = await bot.wait_for('message', check=check)
+        if msg.content == "END":
+            await ctx.send("**Fin de la partie...**")
+            break
+
 
 """
 @bot.command()
